# 2023-05-18, J. Köppern
# %%
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import streamlit as st
import seaborn as sns
# %%

streamlit_texts = {
    "app_title":"Fit polynomial into data 💻☁️",
    "app_text":"""- This Streamlit application is hosted on Microsoft Azure. 
- Its source code is located in a GitHub repository.
- As part of the build pipeline, changes in the repository are automatically applied by Azure and the application is updated.
- An SSL certificate has been deposited with Azure for this web application so that it shows up as *secure* in the user's browser.
- Data is uploaded in a CSV file. They have the columns *x* and *y*.
- Outliers are first removed from the data according to the [Interquartile range](https://en.wikipedia.org/wiki/Interquartile_range):
- - Data windows of specified size are considered.
- - For each window, the limits of the 25% and 75% quantiles are determined.
- - Data points that lie outside these ranges by a factor that can also be defined are removed
- - As an alternative to uploading a CSV file, synthetic data can be generated by the application.
- Polynomials of different degrees are placed in the processed data in such a way that the 2-norm of the approximation error is minimized.
- The polynomials are plotted in each case. A table with the degrees of the polynomials and the respective approximation errors is output.""",
"intro_text":"""- Streamlit app, data cleaning with Pandas, fit polynomials with Numpy, plot using Matplotlib and Seaborn.
- Repository on GitHub, CI/CD pipline via GitHub Actions.
- Hostet as Azure Web Service.
- **Usage**
- - Create noisy data with outliers or upload own CSV file.
- - Remove outliers via IQR method.
- - Fit polynomials of various degrees and see fitting errors."""
}


def remove_outliers(default_window_size, default_multiplyer):
    # Remove outliers
    st.header("Remove outliers")

    
    window_size = st.slider(
        label="Window size in which IQR is applied",
        min_value=5,
        max_value=50,
        value=default_window_size,
        step=1
    )

    multiplier = st.slider(
        label="Window size in which IQR is applied",
        min_value=1.0,
        max_value=20.0,
        value=default_multiplyer,
        step=0.1
    )

    clean_up = st.button("Remove outliers")

    if clean_up:
        if len(st.session_state.df.columns) > 0:
            st.session_state.df_cleaned, st.session_state.df_removed = process_data_in_windows(
                st.session_state.df, 
                "y",
                window_size,
                multiplier=multiplier,
                plot=False)
            
            fig = plt.figure()

            sns.scatterplot(
                data=st.session_state.df_cleaned,
                x = "x", 
                y= "y")
            
            sns.scatterplot(
                data=st.session_state.df_removed,
                x = "x", 
                y= "y",
                color="red")

            # Set title and labels
            plt.title("Cleaned data (removed points are colored red)")
            plt.xlabel("x")
            plt.ylabel("y")

            plt.grid(True)

            st.pyplot(fig)


def fit_poly(df, plot=True):
    if len(df) == 0:
        return

    # Fit polxnomials of various degrees
    df_poly = pd.DataFrame()

    for this_degree in range(10):
        this_poly = np.poly1d(
            np.polyfit(
                df.x,
                df.y,
                this_degree
            )
        )

        y_poly = this_poly(df.x)

        if plot:
            fig = plt.figure()

            plot_xy(df.x, df.y)

            plot_xy(df.x, y_poly)

            plt.title(f"Polynomial degree = {this_degree}")

            st.pyplot(fig)

        mean_squared_error = np.mean((df.y - y_poly)**2)

        df_poly = pd.concat([df_poly, pd.DataFrame({
            "degree": [this_degree],
            "mean_squared_error": [mean_squared_error],
        })], ignore_index=True)

    df_poly = df_poly.reset_index()

    return df_poly

def outlier_detection_iqr(df, column, multiplier):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)

    IQR = Q3 - Q1

    lower_bound = Q1 - multiplier * IQR
    upper_bound = Q3 + multiplier * IQR

    return df.query(f"{column} >= {lower_bound} and {column} < {upper_bound}")

def process_data_in_windows(df, column, window_size, multiplier=1.5, plot=True):
    windows = []

    for i in range(0, len(df), window_size):
        window = df.iloc[i:i + window_size]

        window_clean = outlier_detection_iqr(
            window, 
            column, 
            multiplier
        )

        windows.append(window_clean)

    df_concat = pd.concat(windows, ignore_index=True)

    if plot:
        plot_xy(df_concat.x, df_concat.y)

    df_merged = df.merge(df_concat, how='outer', indicator=True)
    df_removed = df_merged[df_merged['_merge'] == 'left_only']
    df_removed = df_removed.drop(columns=['_merge'])




    return df_concat, df_removed

def insert_section_load_create(raw_data_filename):
    # Load/create df
    st.header("Load/create data")

    col1, col2 = st.columns(2)

    with col1:
        uploaded_file = st.file_uploader("Upload File")

        if uploaded_file is not None:
            st.session_state.df =  pd.read_csv(uploaded_file)

    with col2:
        create_button = st.button("Create")
        
        if create_button:
            st.session_state.df = create_data(raw_data_filename, plot=False)

    st.dataframe(st.session_state.df)

    if len(st.session_state.df.columns) > 0:
        # Create scatter plot
        fig = plt.figure()

        sns.scatterplot(
            data=st.session_state.df,
            x = "x", 
            y= "y")

        # Set title and labels
        plt.title("Raw data")
        plt.xlabel("x")
        plt.ylabel("y")

        plt.grid(True)

        st.pyplot(fig)

def plot_xy(x, y):
    plt.plot(x, y)

    plt.title("Interpolation points")

    plt.grid(True)


# %%
def create_data(filename, plot=True):
    # Crete data
    ## Interpolation points through which the polynomial is to pass
    x = np.array([0, 50, 100, 200, 250, 290, 300])
    y = np.array([0, 50, 110, 170, 130, 120, 120]) / 10



    if plot:
        plot_xy(x, y)

    n_degree = len(x) - 1

    poly = np.poly1d(np.polyfit(x, y, n_degree))

    x_poly = np.linspace(min(x), max(x), 1000)

    y_poly = poly(x_poly)

    if plot:
        plot_xy(x_poly, y_poly)
    # Add noise and outlyers
    noise_percentag = 0.1
    noise_magnitude = noise_percentag * np.abs(y_poly)

    noise = np.random.uniform(
        low=-noise_magnitude, 
        high=noise_magnitude, 
        size=y_poly.shape)

    y_poly_with_noise = y_poly + noise

    # Apply the lower bound of zero
    y_poly_with_noise = np.maximum(y_poly_with_noise, 0)

    if plot:
        plot_xy(x_poly, y_poly_with_noise)
    # Add outliers
    n_outliers = 5

    y_poly_with_noise_outliers = y_poly_with_noise

    outlier_indices = [np.random.randint(0, len(y_poly_with_noise)) for i in range(n_outliers)]


    y_poly_with_noise_outliers[outlier_indices] = 0

    if plot:
        plot_xy(x_poly, y_poly_with_noise_outliers)
    # Create CSV
    # Assuming x_poly and y_poly_with_noise_outliers are your arrays
    data = {'x': x_poly, 'y': y_poly_with_noise_outliers}

    # Create a DataFrame
    df = pd.DataFrame(data)

    df.to_csv(filename, index=False)

    return df